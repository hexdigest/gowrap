package templatestests

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i go.opentelemetry.io/otel/trace.Span -o ./span_opentelemery_mock_test.go -n OpentelemetrySpanMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	mm_trace "go.opentelemetry.io/otel/trace"
)

// OpentelemetrySpanMock implements trace.Span
type OpentelemetrySpanMock struct {
	t minimock.Tester

	funcAddEvent          func(name string, options ...mm_trace.EventOption)
	inspectFuncAddEvent   func(name string, options ...mm_trace.EventOption)
	afterAddEventCounter  uint64
	beforeAddEventCounter uint64
	AddEventMock          mOpentelemetrySpanMockAddEvent

	funcEnd          func(options ...mm_trace.SpanEndOption)
	inspectFuncEnd   func(options ...mm_trace.SpanEndOption)
	afterEndCounter  uint64
	beforeEndCounter uint64
	EndMock          mOpentelemetrySpanMockEnd

	funcIsRecording          func() (b1 bool)
	inspectFuncIsRecording   func()
	afterIsRecordingCounter  uint64
	beforeIsRecordingCounter uint64
	IsRecordingMock          mOpentelemetrySpanMockIsRecording

	funcRecordError          func(err error, options ...mm_trace.EventOption)
	inspectFuncRecordError   func(err error, options ...mm_trace.EventOption)
	afterRecordErrorCounter  uint64
	beforeRecordErrorCounter uint64
	RecordErrorMock          mOpentelemetrySpanMockRecordError

	funcSetAttributes          func(kv ...attribute.KeyValue)
	inspectFuncSetAttributes   func(kv ...attribute.KeyValue)
	afterSetAttributesCounter  uint64
	beforeSetAttributesCounter uint64
	SetAttributesMock          mOpentelemetrySpanMockSetAttributes

	funcSetName          func(name string)
	inspectFuncSetName   func(name string)
	afterSetNameCounter  uint64
	beforeSetNameCounter uint64
	SetNameMock          mOpentelemetrySpanMockSetName

	funcSetStatus          func(code codes.Code, description string)
	inspectFuncSetStatus   func(code codes.Code, description string)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOpentelemetrySpanMockSetStatus

	funcSpanContext          func() (s1 mm_trace.SpanContext)
	inspectFuncSpanContext   func()
	afterSpanContextCounter  uint64
	beforeSpanContextCounter uint64
	SpanContextMock          mOpentelemetrySpanMockSpanContext

	funcTracerProvider          func() (t1 mm_trace.TracerProvider)
	inspectFuncTracerProvider   func()
	afterTracerProviderCounter  uint64
	beforeTracerProviderCounter uint64
	TracerProviderMock          mOpentelemetrySpanMockTracerProvider
}

// NewOpentelemetrySpanMock returns a mock for trace.Span
func NewOpentelemetrySpanMock(t minimock.Tester) *OpentelemetrySpanMock {
	m := &OpentelemetrySpanMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddEventMock = mOpentelemetrySpanMockAddEvent{mock: m}
	m.AddEventMock.callArgs = []*OpentelemetrySpanMockAddEventParams{}

	m.EndMock = mOpentelemetrySpanMockEnd{mock: m}
	m.EndMock.callArgs = []*OpentelemetrySpanMockEndParams{}

	m.IsRecordingMock = mOpentelemetrySpanMockIsRecording{mock: m}

	m.RecordErrorMock = mOpentelemetrySpanMockRecordError{mock: m}
	m.RecordErrorMock.callArgs = []*OpentelemetrySpanMockRecordErrorParams{}

	m.SetAttributesMock = mOpentelemetrySpanMockSetAttributes{mock: m}
	m.SetAttributesMock.callArgs = []*OpentelemetrySpanMockSetAttributesParams{}

	m.SetNameMock = mOpentelemetrySpanMockSetName{mock: m}
	m.SetNameMock.callArgs = []*OpentelemetrySpanMockSetNameParams{}

	m.SetStatusMock = mOpentelemetrySpanMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OpentelemetrySpanMockSetStatusParams{}

	m.SpanContextMock = mOpentelemetrySpanMockSpanContext{mock: m}

	m.TracerProviderMock = mOpentelemetrySpanMockTracerProvider{mock: m}

	return m
}

type mOpentelemetrySpanMockAddEvent struct {
	mock               *OpentelemetrySpanMock
	defaultExpectation *OpentelemetrySpanMockAddEventExpectation
	expectations       []*OpentelemetrySpanMockAddEventExpectation

	callArgs []*OpentelemetrySpanMockAddEventParams
	mutex    sync.RWMutex
}

// OpentelemetrySpanMockAddEventExpectation specifies expectation struct of the Span.AddEvent
type OpentelemetrySpanMockAddEventExpectation struct {
	mock   *OpentelemetrySpanMock
	params *OpentelemetrySpanMockAddEventParams

	Counter uint64
}

// OpentelemetrySpanMockAddEventParams contains parameters of the Span.AddEvent
type OpentelemetrySpanMockAddEventParams struct {
	name    string
	options []mm_trace.EventOption
}

// Expect sets up expected params for Span.AddEvent
func (mmAddEvent *mOpentelemetrySpanMockAddEvent) Expect(name string, options ...mm_trace.EventOption) *mOpentelemetrySpanMockAddEvent {
	if mmAddEvent.mock.funcAddEvent != nil {
		mmAddEvent.mock.t.Fatalf("OpentelemetrySpanMock.AddEvent mock is already set by Set")
	}

	if mmAddEvent.defaultExpectation == nil {
		mmAddEvent.defaultExpectation = &OpentelemetrySpanMockAddEventExpectation{}
	}

	mmAddEvent.defaultExpectation.params = &OpentelemetrySpanMockAddEventParams{name, options}
	for _, e := range mmAddEvent.expectations {
		if minimock.Equal(e.params, mmAddEvent.defaultExpectation.params) {
			mmAddEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddEvent.defaultExpectation.params)
		}
	}

	return mmAddEvent
}

// Inspect accepts an inspector function that has same arguments as the Span.AddEvent
func (mmAddEvent *mOpentelemetrySpanMockAddEvent) Inspect(f func(name string, options ...mm_trace.EventOption)) *mOpentelemetrySpanMockAddEvent {
	if mmAddEvent.mock.inspectFuncAddEvent != nil {
		mmAddEvent.mock.t.Fatalf("Inspect function is already set for OpentelemetrySpanMock.AddEvent")
	}

	mmAddEvent.mock.inspectFuncAddEvent = f

	return mmAddEvent
}

// Return sets up results that will be returned by Span.AddEvent
func (mmAddEvent *mOpentelemetrySpanMockAddEvent) Return() *OpentelemetrySpanMock {
	if mmAddEvent.mock.funcAddEvent != nil {
		mmAddEvent.mock.t.Fatalf("OpentelemetrySpanMock.AddEvent mock is already set by Set")
	}

	if mmAddEvent.defaultExpectation == nil {
		mmAddEvent.defaultExpectation = &OpentelemetrySpanMockAddEventExpectation{mock: mmAddEvent.mock}
	}

	return mmAddEvent.mock
}

// Set uses given function f to mock the Span.AddEvent method
func (mmAddEvent *mOpentelemetrySpanMockAddEvent) Set(f func(name string, options ...mm_trace.EventOption)) *OpentelemetrySpanMock {
	if mmAddEvent.defaultExpectation != nil {
		mmAddEvent.mock.t.Fatalf("Default expectation is already set for the Span.AddEvent method")
	}

	if len(mmAddEvent.expectations) > 0 {
		mmAddEvent.mock.t.Fatalf("Some expectations are already set for the Span.AddEvent method")
	}

	mmAddEvent.mock.funcAddEvent = f
	return mmAddEvent.mock
}

// AddEvent implements trace.Span
func (mmAddEvent *OpentelemetrySpanMock) AddEvent(name string, options ...mm_trace.EventOption) {
	mm_atomic.AddUint64(&mmAddEvent.beforeAddEventCounter, 1)
	defer mm_atomic.AddUint64(&mmAddEvent.afterAddEventCounter, 1)

	if mmAddEvent.inspectFuncAddEvent != nil {
		mmAddEvent.inspectFuncAddEvent(name, options...)
	}

	mm_params := &OpentelemetrySpanMockAddEventParams{name, options}

	// Record call args
	mmAddEvent.AddEventMock.mutex.Lock()
	mmAddEvent.AddEventMock.callArgs = append(mmAddEvent.AddEventMock.callArgs, mm_params)
	mmAddEvent.AddEventMock.mutex.Unlock()

	for _, e := range mmAddEvent.AddEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddEvent.AddEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddEvent.AddEventMock.defaultExpectation.Counter, 1)
		mm_want := mmAddEvent.AddEventMock.defaultExpectation.params
		mm_got := OpentelemetrySpanMockAddEventParams{name, options}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddEvent.t.Errorf("OpentelemetrySpanMock.AddEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddEvent.funcAddEvent != nil {
		mmAddEvent.funcAddEvent(name, options...)
		return
	}
	mmAddEvent.t.Fatalf("Unexpected call to OpentelemetrySpanMock.AddEvent. %v %v", name, options)

}

// AddEventAfterCounter returns a count of finished OpentelemetrySpanMock.AddEvent invocations
func (mmAddEvent *OpentelemetrySpanMock) AddEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddEvent.afterAddEventCounter)
}

// AddEventBeforeCounter returns a count of OpentelemetrySpanMock.AddEvent invocations
func (mmAddEvent *OpentelemetrySpanMock) AddEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddEvent.beforeAddEventCounter)
}

// Calls returns a list of arguments used in each call to OpentelemetrySpanMock.AddEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddEvent *mOpentelemetrySpanMockAddEvent) Calls() []*OpentelemetrySpanMockAddEventParams {
	mmAddEvent.mutex.RLock()

	argCopy := make([]*OpentelemetrySpanMockAddEventParams, len(mmAddEvent.callArgs))
	copy(argCopy, mmAddEvent.callArgs)

	mmAddEvent.mutex.RUnlock()

	return argCopy
}

// MinimockAddEventDone returns true if the count of the AddEvent invocations corresponds
// the number of defined expectations
func (m *OpentelemetrySpanMock) MinimockAddEventDone() bool {
	for _, e := range m.AddEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddEvent != nil && mm_atomic.LoadUint64(&m.afterAddEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddEventInspect logs each unmet expectation
func (m *OpentelemetrySpanMock) MinimockAddEventInspect() {
	for _, e := range m.AddEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.AddEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddEventCounter) < 1 {
		if m.AddEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OpentelemetrySpanMock.AddEvent")
		} else {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.AddEvent with params: %#v", *m.AddEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddEvent != nil && mm_atomic.LoadUint64(&m.afterAddEventCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.AddEvent")
	}
}

type mOpentelemetrySpanMockEnd struct {
	mock               *OpentelemetrySpanMock
	defaultExpectation *OpentelemetrySpanMockEndExpectation
	expectations       []*OpentelemetrySpanMockEndExpectation

	callArgs []*OpentelemetrySpanMockEndParams
	mutex    sync.RWMutex
}

// OpentelemetrySpanMockEndExpectation specifies expectation struct of the Span.End
type OpentelemetrySpanMockEndExpectation struct {
	mock   *OpentelemetrySpanMock
	params *OpentelemetrySpanMockEndParams

	Counter uint64
}

// OpentelemetrySpanMockEndParams contains parameters of the Span.End
type OpentelemetrySpanMockEndParams struct {
	options []mm_trace.SpanEndOption
}

// Expect sets up expected params for Span.End
func (mmEnd *mOpentelemetrySpanMockEnd) Expect(options ...mm_trace.SpanEndOption) *mOpentelemetrySpanMockEnd {
	if mmEnd.mock.funcEnd != nil {
		mmEnd.mock.t.Fatalf("OpentelemetrySpanMock.End mock is already set by Set")
	}

	if mmEnd.defaultExpectation == nil {
		mmEnd.defaultExpectation = &OpentelemetrySpanMockEndExpectation{}
	}

	mmEnd.defaultExpectation.params = &OpentelemetrySpanMockEndParams{options}
	for _, e := range mmEnd.expectations {
		if minimock.Equal(e.params, mmEnd.defaultExpectation.params) {
			mmEnd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEnd.defaultExpectation.params)
		}
	}

	return mmEnd
}

// Inspect accepts an inspector function that has same arguments as the Span.End
func (mmEnd *mOpentelemetrySpanMockEnd) Inspect(f func(options ...mm_trace.SpanEndOption)) *mOpentelemetrySpanMockEnd {
	if mmEnd.mock.inspectFuncEnd != nil {
		mmEnd.mock.t.Fatalf("Inspect function is already set for OpentelemetrySpanMock.End")
	}

	mmEnd.mock.inspectFuncEnd = f

	return mmEnd
}

// Return sets up results that will be returned by Span.End
func (mmEnd *mOpentelemetrySpanMockEnd) Return() *OpentelemetrySpanMock {
	if mmEnd.mock.funcEnd != nil {
		mmEnd.mock.t.Fatalf("OpentelemetrySpanMock.End mock is already set by Set")
	}

	if mmEnd.defaultExpectation == nil {
		mmEnd.defaultExpectation = &OpentelemetrySpanMockEndExpectation{mock: mmEnd.mock}
	}

	return mmEnd.mock
}

// Set uses given function f to mock the Span.End method
func (mmEnd *mOpentelemetrySpanMockEnd) Set(f func(options ...mm_trace.SpanEndOption)) *OpentelemetrySpanMock {
	if mmEnd.defaultExpectation != nil {
		mmEnd.mock.t.Fatalf("Default expectation is already set for the Span.End method")
	}

	if len(mmEnd.expectations) > 0 {
		mmEnd.mock.t.Fatalf("Some expectations are already set for the Span.End method")
	}

	mmEnd.mock.funcEnd = f
	return mmEnd.mock
}

// End implements trace.Span
func (mmEnd *OpentelemetrySpanMock) End(options ...mm_trace.SpanEndOption) {
	mm_atomic.AddUint64(&mmEnd.beforeEndCounter, 1)
	defer mm_atomic.AddUint64(&mmEnd.afterEndCounter, 1)

	if mmEnd.inspectFuncEnd != nil {
		mmEnd.inspectFuncEnd(options...)
	}

	mm_params := &OpentelemetrySpanMockEndParams{options}

	// Record call args
	mmEnd.EndMock.mutex.Lock()
	mmEnd.EndMock.callArgs = append(mmEnd.EndMock.callArgs, mm_params)
	mmEnd.EndMock.mutex.Unlock()

	for _, e := range mmEnd.EndMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmEnd.EndMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnd.EndMock.defaultExpectation.Counter, 1)
		mm_want := mmEnd.EndMock.defaultExpectation.params
		mm_got := OpentelemetrySpanMockEndParams{options}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEnd.t.Errorf("OpentelemetrySpanMock.End got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmEnd.funcEnd != nil {
		mmEnd.funcEnd(options...)
		return
	}
	mmEnd.t.Fatalf("Unexpected call to OpentelemetrySpanMock.End. %v", options)

}

// EndAfterCounter returns a count of finished OpentelemetrySpanMock.End invocations
func (mmEnd *OpentelemetrySpanMock) EndAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnd.afterEndCounter)
}

// EndBeforeCounter returns a count of OpentelemetrySpanMock.End invocations
func (mmEnd *OpentelemetrySpanMock) EndBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnd.beforeEndCounter)
}

// Calls returns a list of arguments used in each call to OpentelemetrySpanMock.End.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEnd *mOpentelemetrySpanMockEnd) Calls() []*OpentelemetrySpanMockEndParams {
	mmEnd.mutex.RLock()

	argCopy := make([]*OpentelemetrySpanMockEndParams, len(mmEnd.callArgs))
	copy(argCopy, mmEnd.callArgs)

	mmEnd.mutex.RUnlock()

	return argCopy
}

// MinimockEndDone returns true if the count of the End invocations corresponds
// the number of defined expectations
func (m *OpentelemetrySpanMock) MinimockEndDone() bool {
	for _, e := range m.EndMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EndMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEndCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnd != nil && mm_atomic.LoadUint64(&m.afterEndCounter) < 1 {
		return false
	}
	return true
}

// MinimockEndInspect logs each unmet expectation
func (m *OpentelemetrySpanMock) MinimockEndInspect() {
	for _, e := range m.EndMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.End with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EndMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEndCounter) < 1 {
		if m.EndMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OpentelemetrySpanMock.End")
		} else {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.End with params: %#v", *m.EndMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnd != nil && mm_atomic.LoadUint64(&m.afterEndCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.End")
	}
}

type mOpentelemetrySpanMockIsRecording struct {
	mock               *OpentelemetrySpanMock
	defaultExpectation *OpentelemetrySpanMockIsRecordingExpectation
	expectations       []*OpentelemetrySpanMockIsRecordingExpectation
}

// OpentelemetrySpanMockIsRecordingExpectation specifies expectation struct of the Span.IsRecording
type OpentelemetrySpanMockIsRecordingExpectation struct {
	mock *OpentelemetrySpanMock

	results *OpentelemetrySpanMockIsRecordingResults
	Counter uint64
}

// OpentelemetrySpanMockIsRecordingResults contains results of the Span.IsRecording
type OpentelemetrySpanMockIsRecordingResults struct {
	b1 bool
}

// Expect sets up expected params for Span.IsRecording
func (mmIsRecording *mOpentelemetrySpanMockIsRecording) Expect() *mOpentelemetrySpanMockIsRecording {
	if mmIsRecording.mock.funcIsRecording != nil {
		mmIsRecording.mock.t.Fatalf("OpentelemetrySpanMock.IsRecording mock is already set by Set")
	}

	if mmIsRecording.defaultExpectation == nil {
		mmIsRecording.defaultExpectation = &OpentelemetrySpanMockIsRecordingExpectation{}
	}

	return mmIsRecording
}

// Inspect accepts an inspector function that has same arguments as the Span.IsRecording
func (mmIsRecording *mOpentelemetrySpanMockIsRecording) Inspect(f func()) *mOpentelemetrySpanMockIsRecording {
	if mmIsRecording.mock.inspectFuncIsRecording != nil {
		mmIsRecording.mock.t.Fatalf("Inspect function is already set for OpentelemetrySpanMock.IsRecording")
	}

	mmIsRecording.mock.inspectFuncIsRecording = f

	return mmIsRecording
}

// Return sets up results that will be returned by Span.IsRecording
func (mmIsRecording *mOpentelemetrySpanMockIsRecording) Return(b1 bool) *OpentelemetrySpanMock {
	if mmIsRecording.mock.funcIsRecording != nil {
		mmIsRecording.mock.t.Fatalf("OpentelemetrySpanMock.IsRecording mock is already set by Set")
	}

	if mmIsRecording.defaultExpectation == nil {
		mmIsRecording.defaultExpectation = &OpentelemetrySpanMockIsRecordingExpectation{mock: mmIsRecording.mock}
	}
	mmIsRecording.defaultExpectation.results = &OpentelemetrySpanMockIsRecordingResults{b1}
	return mmIsRecording.mock
}

// Set uses given function f to mock the Span.IsRecording method
func (mmIsRecording *mOpentelemetrySpanMockIsRecording) Set(f func() (b1 bool)) *OpentelemetrySpanMock {
	if mmIsRecording.defaultExpectation != nil {
		mmIsRecording.mock.t.Fatalf("Default expectation is already set for the Span.IsRecording method")
	}

	if len(mmIsRecording.expectations) > 0 {
		mmIsRecording.mock.t.Fatalf("Some expectations are already set for the Span.IsRecording method")
	}

	mmIsRecording.mock.funcIsRecording = f
	return mmIsRecording.mock
}

// IsRecording implements trace.Span
func (mmIsRecording *OpentelemetrySpanMock) IsRecording() (b1 bool) {
	mm_atomic.AddUint64(&mmIsRecording.beforeIsRecordingCounter, 1)
	defer mm_atomic.AddUint64(&mmIsRecording.afterIsRecordingCounter, 1)

	if mmIsRecording.inspectFuncIsRecording != nil {
		mmIsRecording.inspectFuncIsRecording()
	}

	if mmIsRecording.IsRecordingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsRecording.IsRecordingMock.defaultExpectation.Counter, 1)

		mm_results := mmIsRecording.IsRecordingMock.defaultExpectation.results
		if mm_results == nil {
			mmIsRecording.t.Fatal("No results are set for the OpentelemetrySpanMock.IsRecording")
		}
		return (*mm_results).b1
	}
	if mmIsRecording.funcIsRecording != nil {
		return mmIsRecording.funcIsRecording()
	}
	mmIsRecording.t.Fatalf("Unexpected call to OpentelemetrySpanMock.IsRecording.")
	return
}

// IsRecordingAfterCounter returns a count of finished OpentelemetrySpanMock.IsRecording invocations
func (mmIsRecording *OpentelemetrySpanMock) IsRecordingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRecording.afterIsRecordingCounter)
}

// IsRecordingBeforeCounter returns a count of OpentelemetrySpanMock.IsRecording invocations
func (mmIsRecording *OpentelemetrySpanMock) IsRecordingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRecording.beforeIsRecordingCounter)
}

// MinimockIsRecordingDone returns true if the count of the IsRecording invocations corresponds
// the number of defined expectations
func (m *OpentelemetrySpanMock) MinimockIsRecordingDone() bool {
	for _, e := range m.IsRecordingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsRecordingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsRecordingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsRecording != nil && mm_atomic.LoadUint64(&m.afterIsRecordingCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsRecordingInspect logs each unmet expectation
func (m *OpentelemetrySpanMock) MinimockIsRecordingInspect() {
	for _, e := range m.IsRecordingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to OpentelemetrySpanMock.IsRecording")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsRecordingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsRecordingCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.IsRecording")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsRecording != nil && mm_atomic.LoadUint64(&m.afterIsRecordingCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.IsRecording")
	}
}

type mOpentelemetrySpanMockRecordError struct {
	mock               *OpentelemetrySpanMock
	defaultExpectation *OpentelemetrySpanMockRecordErrorExpectation
	expectations       []*OpentelemetrySpanMockRecordErrorExpectation

	callArgs []*OpentelemetrySpanMockRecordErrorParams
	mutex    sync.RWMutex
}

// OpentelemetrySpanMockRecordErrorExpectation specifies expectation struct of the Span.RecordError
type OpentelemetrySpanMockRecordErrorExpectation struct {
	mock   *OpentelemetrySpanMock
	params *OpentelemetrySpanMockRecordErrorParams

	Counter uint64
}

// OpentelemetrySpanMockRecordErrorParams contains parameters of the Span.RecordError
type OpentelemetrySpanMockRecordErrorParams struct {
	err     error
	options []mm_trace.EventOption
}

// Expect sets up expected params for Span.RecordError
func (mmRecordError *mOpentelemetrySpanMockRecordError) Expect(err error, options ...mm_trace.EventOption) *mOpentelemetrySpanMockRecordError {
	if mmRecordError.mock.funcRecordError != nil {
		mmRecordError.mock.t.Fatalf("OpentelemetrySpanMock.RecordError mock is already set by Set")
	}

	if mmRecordError.defaultExpectation == nil {
		mmRecordError.defaultExpectation = &OpentelemetrySpanMockRecordErrorExpectation{}
	}

	mmRecordError.defaultExpectation.params = &OpentelemetrySpanMockRecordErrorParams{err, options}
	for _, e := range mmRecordError.expectations {
		if minimock.Equal(e.params, mmRecordError.defaultExpectation.params) {
			mmRecordError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecordError.defaultExpectation.params)
		}
	}

	return mmRecordError
}

// Inspect accepts an inspector function that has same arguments as the Span.RecordError
func (mmRecordError *mOpentelemetrySpanMockRecordError) Inspect(f func(err error, options ...mm_trace.EventOption)) *mOpentelemetrySpanMockRecordError {
	if mmRecordError.mock.inspectFuncRecordError != nil {
		mmRecordError.mock.t.Fatalf("Inspect function is already set for OpentelemetrySpanMock.RecordError")
	}

	mmRecordError.mock.inspectFuncRecordError = f

	return mmRecordError
}

// Return sets up results that will be returned by Span.RecordError
func (mmRecordError *mOpentelemetrySpanMockRecordError) Return() *OpentelemetrySpanMock {
	if mmRecordError.mock.funcRecordError != nil {
		mmRecordError.mock.t.Fatalf("OpentelemetrySpanMock.RecordError mock is already set by Set")
	}

	if mmRecordError.defaultExpectation == nil {
		mmRecordError.defaultExpectation = &OpentelemetrySpanMockRecordErrorExpectation{mock: mmRecordError.mock}
	}

	return mmRecordError.mock
}

// Set uses given function f to mock the Span.RecordError method
func (mmRecordError *mOpentelemetrySpanMockRecordError) Set(f func(err error, options ...mm_trace.EventOption)) *OpentelemetrySpanMock {
	if mmRecordError.defaultExpectation != nil {
		mmRecordError.mock.t.Fatalf("Default expectation is already set for the Span.RecordError method")
	}

	if len(mmRecordError.expectations) > 0 {
		mmRecordError.mock.t.Fatalf("Some expectations are already set for the Span.RecordError method")
	}

	mmRecordError.mock.funcRecordError = f
	return mmRecordError.mock
}

// RecordError implements trace.Span
func (mmRecordError *OpentelemetrySpanMock) RecordError(err error, options ...mm_trace.EventOption) {
	mm_atomic.AddUint64(&mmRecordError.beforeRecordErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmRecordError.afterRecordErrorCounter, 1)

	if mmRecordError.inspectFuncRecordError != nil {
		mmRecordError.inspectFuncRecordError(err, options...)
	}

	mm_params := &OpentelemetrySpanMockRecordErrorParams{err, options}

	// Record call args
	mmRecordError.RecordErrorMock.mutex.Lock()
	mmRecordError.RecordErrorMock.callArgs = append(mmRecordError.RecordErrorMock.callArgs, mm_params)
	mmRecordError.RecordErrorMock.mutex.Unlock()

	for _, e := range mmRecordError.RecordErrorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRecordError.RecordErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecordError.RecordErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmRecordError.RecordErrorMock.defaultExpectation.params
		mm_got := OpentelemetrySpanMockRecordErrorParams{err, options}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRecordError.t.Errorf("OpentelemetrySpanMock.RecordError got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmRecordError.funcRecordError != nil {
		mmRecordError.funcRecordError(err, options...)
		return
	}
	mmRecordError.t.Fatalf("Unexpected call to OpentelemetrySpanMock.RecordError. %v %v", err, options)

}

// RecordErrorAfterCounter returns a count of finished OpentelemetrySpanMock.RecordError invocations
func (mmRecordError *OpentelemetrySpanMock) RecordErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecordError.afterRecordErrorCounter)
}

// RecordErrorBeforeCounter returns a count of OpentelemetrySpanMock.RecordError invocations
func (mmRecordError *OpentelemetrySpanMock) RecordErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecordError.beforeRecordErrorCounter)
}

// Calls returns a list of arguments used in each call to OpentelemetrySpanMock.RecordError.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecordError *mOpentelemetrySpanMockRecordError) Calls() []*OpentelemetrySpanMockRecordErrorParams {
	mmRecordError.mutex.RLock()

	argCopy := make([]*OpentelemetrySpanMockRecordErrorParams, len(mmRecordError.callArgs))
	copy(argCopy, mmRecordError.callArgs)

	mmRecordError.mutex.RUnlock()

	return argCopy
}

// MinimockRecordErrorDone returns true if the count of the RecordError invocations corresponds
// the number of defined expectations
func (m *OpentelemetrySpanMock) MinimockRecordErrorDone() bool {
	for _, e := range m.RecordErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecordErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecordErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecordError != nil && mm_atomic.LoadUint64(&m.afterRecordErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecordErrorInspect logs each unmet expectation
func (m *OpentelemetrySpanMock) MinimockRecordErrorInspect() {
	for _, e := range m.RecordErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.RecordError with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecordErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecordErrorCounter) < 1 {
		if m.RecordErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OpentelemetrySpanMock.RecordError")
		} else {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.RecordError with params: %#v", *m.RecordErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecordError != nil && mm_atomic.LoadUint64(&m.afterRecordErrorCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.RecordError")
	}
}

type mOpentelemetrySpanMockSetAttributes struct {
	mock               *OpentelemetrySpanMock
	defaultExpectation *OpentelemetrySpanMockSetAttributesExpectation
	expectations       []*OpentelemetrySpanMockSetAttributesExpectation

	callArgs []*OpentelemetrySpanMockSetAttributesParams
	mutex    sync.RWMutex
}

// OpentelemetrySpanMockSetAttributesExpectation specifies expectation struct of the Span.SetAttributes
type OpentelemetrySpanMockSetAttributesExpectation struct {
	mock   *OpentelemetrySpanMock
	params *OpentelemetrySpanMockSetAttributesParams

	Counter uint64
}

// OpentelemetrySpanMockSetAttributesParams contains parameters of the Span.SetAttributes
type OpentelemetrySpanMockSetAttributesParams struct {
	kv []attribute.KeyValue
}

// Expect sets up expected params for Span.SetAttributes
func (mmSetAttributes *mOpentelemetrySpanMockSetAttributes) Expect(kv ...attribute.KeyValue) *mOpentelemetrySpanMockSetAttributes {
	if mmSetAttributes.mock.funcSetAttributes != nil {
		mmSetAttributes.mock.t.Fatalf("OpentelemetrySpanMock.SetAttributes mock is already set by Set")
	}

	if mmSetAttributes.defaultExpectation == nil {
		mmSetAttributes.defaultExpectation = &OpentelemetrySpanMockSetAttributesExpectation{}
	}

	mmSetAttributes.defaultExpectation.params = &OpentelemetrySpanMockSetAttributesParams{kv}
	for _, e := range mmSetAttributes.expectations {
		if minimock.Equal(e.params, mmSetAttributes.defaultExpectation.params) {
			mmSetAttributes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetAttributes.defaultExpectation.params)
		}
	}

	return mmSetAttributes
}

// Inspect accepts an inspector function that has same arguments as the Span.SetAttributes
func (mmSetAttributes *mOpentelemetrySpanMockSetAttributes) Inspect(f func(kv ...attribute.KeyValue)) *mOpentelemetrySpanMockSetAttributes {
	if mmSetAttributes.mock.inspectFuncSetAttributes != nil {
		mmSetAttributes.mock.t.Fatalf("Inspect function is already set for OpentelemetrySpanMock.SetAttributes")
	}

	mmSetAttributes.mock.inspectFuncSetAttributes = f

	return mmSetAttributes
}

// Return sets up results that will be returned by Span.SetAttributes
func (mmSetAttributes *mOpentelemetrySpanMockSetAttributes) Return() *OpentelemetrySpanMock {
	if mmSetAttributes.mock.funcSetAttributes != nil {
		mmSetAttributes.mock.t.Fatalf("OpentelemetrySpanMock.SetAttributes mock is already set by Set")
	}

	if mmSetAttributes.defaultExpectation == nil {
		mmSetAttributes.defaultExpectation = &OpentelemetrySpanMockSetAttributesExpectation{mock: mmSetAttributes.mock}
	}

	return mmSetAttributes.mock
}

// Set uses given function f to mock the Span.SetAttributes method
func (mmSetAttributes *mOpentelemetrySpanMockSetAttributes) Set(f func(kv ...attribute.KeyValue)) *OpentelemetrySpanMock {
	if mmSetAttributes.defaultExpectation != nil {
		mmSetAttributes.mock.t.Fatalf("Default expectation is already set for the Span.SetAttributes method")
	}

	if len(mmSetAttributes.expectations) > 0 {
		mmSetAttributes.mock.t.Fatalf("Some expectations are already set for the Span.SetAttributes method")
	}

	mmSetAttributes.mock.funcSetAttributes = f
	return mmSetAttributes.mock
}

// SetAttributes implements trace.Span
func (mmSetAttributes *OpentelemetrySpanMock) SetAttributes(kv ...attribute.KeyValue) {
	mm_atomic.AddUint64(&mmSetAttributes.beforeSetAttributesCounter, 1)
	defer mm_atomic.AddUint64(&mmSetAttributes.afterSetAttributesCounter, 1)

	if mmSetAttributes.inspectFuncSetAttributes != nil {
		mmSetAttributes.inspectFuncSetAttributes(kv...)
	}

	mm_params := &OpentelemetrySpanMockSetAttributesParams{kv}

	// Record call args
	mmSetAttributes.SetAttributesMock.mutex.Lock()
	mmSetAttributes.SetAttributesMock.callArgs = append(mmSetAttributes.SetAttributesMock.callArgs, mm_params)
	mmSetAttributes.SetAttributesMock.mutex.Unlock()

	for _, e := range mmSetAttributes.SetAttributesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetAttributes.SetAttributesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetAttributes.SetAttributesMock.defaultExpectation.Counter, 1)
		mm_want := mmSetAttributes.SetAttributesMock.defaultExpectation.params
		mm_got := OpentelemetrySpanMockSetAttributesParams{kv}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetAttributes.t.Errorf("OpentelemetrySpanMock.SetAttributes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetAttributes.funcSetAttributes != nil {
		mmSetAttributes.funcSetAttributes(kv...)
		return
	}
	mmSetAttributes.t.Fatalf("Unexpected call to OpentelemetrySpanMock.SetAttributes. %v", kv)

}

// SetAttributesAfterCounter returns a count of finished OpentelemetrySpanMock.SetAttributes invocations
func (mmSetAttributes *OpentelemetrySpanMock) SetAttributesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetAttributes.afterSetAttributesCounter)
}

// SetAttributesBeforeCounter returns a count of OpentelemetrySpanMock.SetAttributes invocations
func (mmSetAttributes *OpentelemetrySpanMock) SetAttributesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetAttributes.beforeSetAttributesCounter)
}

// Calls returns a list of arguments used in each call to OpentelemetrySpanMock.SetAttributes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetAttributes *mOpentelemetrySpanMockSetAttributes) Calls() []*OpentelemetrySpanMockSetAttributesParams {
	mmSetAttributes.mutex.RLock()

	argCopy := make([]*OpentelemetrySpanMockSetAttributesParams, len(mmSetAttributes.callArgs))
	copy(argCopy, mmSetAttributes.callArgs)

	mmSetAttributes.mutex.RUnlock()

	return argCopy
}

// MinimockSetAttributesDone returns true if the count of the SetAttributes invocations corresponds
// the number of defined expectations
func (m *OpentelemetrySpanMock) MinimockSetAttributesDone() bool {
	for _, e := range m.SetAttributesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetAttributesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetAttributesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetAttributes != nil && mm_atomic.LoadUint64(&m.afterSetAttributesCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetAttributesInspect logs each unmet expectation
func (m *OpentelemetrySpanMock) MinimockSetAttributesInspect() {
	for _, e := range m.SetAttributesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.SetAttributes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetAttributesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetAttributesCounter) < 1 {
		if m.SetAttributesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OpentelemetrySpanMock.SetAttributes")
		} else {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.SetAttributes with params: %#v", *m.SetAttributesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetAttributes != nil && mm_atomic.LoadUint64(&m.afterSetAttributesCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.SetAttributes")
	}
}

type mOpentelemetrySpanMockSetName struct {
	mock               *OpentelemetrySpanMock
	defaultExpectation *OpentelemetrySpanMockSetNameExpectation
	expectations       []*OpentelemetrySpanMockSetNameExpectation

	callArgs []*OpentelemetrySpanMockSetNameParams
	mutex    sync.RWMutex
}

// OpentelemetrySpanMockSetNameExpectation specifies expectation struct of the Span.SetName
type OpentelemetrySpanMockSetNameExpectation struct {
	mock   *OpentelemetrySpanMock
	params *OpentelemetrySpanMockSetNameParams

	Counter uint64
}

// OpentelemetrySpanMockSetNameParams contains parameters of the Span.SetName
type OpentelemetrySpanMockSetNameParams struct {
	name string
}

// Expect sets up expected params for Span.SetName
func (mmSetName *mOpentelemetrySpanMockSetName) Expect(name string) *mOpentelemetrySpanMockSetName {
	if mmSetName.mock.funcSetName != nil {
		mmSetName.mock.t.Fatalf("OpentelemetrySpanMock.SetName mock is already set by Set")
	}

	if mmSetName.defaultExpectation == nil {
		mmSetName.defaultExpectation = &OpentelemetrySpanMockSetNameExpectation{}
	}

	mmSetName.defaultExpectation.params = &OpentelemetrySpanMockSetNameParams{name}
	for _, e := range mmSetName.expectations {
		if minimock.Equal(e.params, mmSetName.defaultExpectation.params) {
			mmSetName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetName.defaultExpectation.params)
		}
	}

	return mmSetName
}

// Inspect accepts an inspector function that has same arguments as the Span.SetName
func (mmSetName *mOpentelemetrySpanMockSetName) Inspect(f func(name string)) *mOpentelemetrySpanMockSetName {
	if mmSetName.mock.inspectFuncSetName != nil {
		mmSetName.mock.t.Fatalf("Inspect function is already set for OpentelemetrySpanMock.SetName")
	}

	mmSetName.mock.inspectFuncSetName = f

	return mmSetName
}

// Return sets up results that will be returned by Span.SetName
func (mmSetName *mOpentelemetrySpanMockSetName) Return() *OpentelemetrySpanMock {
	if mmSetName.mock.funcSetName != nil {
		mmSetName.mock.t.Fatalf("OpentelemetrySpanMock.SetName mock is already set by Set")
	}

	if mmSetName.defaultExpectation == nil {
		mmSetName.defaultExpectation = &OpentelemetrySpanMockSetNameExpectation{mock: mmSetName.mock}
	}

	return mmSetName.mock
}

// Set uses given function f to mock the Span.SetName method
func (mmSetName *mOpentelemetrySpanMockSetName) Set(f func(name string)) *OpentelemetrySpanMock {
	if mmSetName.defaultExpectation != nil {
		mmSetName.mock.t.Fatalf("Default expectation is already set for the Span.SetName method")
	}

	if len(mmSetName.expectations) > 0 {
		mmSetName.mock.t.Fatalf("Some expectations are already set for the Span.SetName method")
	}

	mmSetName.mock.funcSetName = f
	return mmSetName.mock
}

// SetName implements trace.Span
func (mmSetName *OpentelemetrySpanMock) SetName(name string) {
	mm_atomic.AddUint64(&mmSetName.beforeSetNameCounter, 1)
	defer mm_atomic.AddUint64(&mmSetName.afterSetNameCounter, 1)

	if mmSetName.inspectFuncSetName != nil {
		mmSetName.inspectFuncSetName(name)
	}

	mm_params := &OpentelemetrySpanMockSetNameParams{name}

	// Record call args
	mmSetName.SetNameMock.mutex.Lock()
	mmSetName.SetNameMock.callArgs = append(mmSetName.SetNameMock.callArgs, mm_params)
	mmSetName.SetNameMock.mutex.Unlock()

	for _, e := range mmSetName.SetNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetName.SetNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetName.SetNameMock.defaultExpectation.Counter, 1)
		mm_want := mmSetName.SetNameMock.defaultExpectation.params
		mm_got := OpentelemetrySpanMockSetNameParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetName.t.Errorf("OpentelemetrySpanMock.SetName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetName.funcSetName != nil {
		mmSetName.funcSetName(name)
		return
	}
	mmSetName.t.Fatalf("Unexpected call to OpentelemetrySpanMock.SetName. %v", name)

}

// SetNameAfterCounter returns a count of finished OpentelemetrySpanMock.SetName invocations
func (mmSetName *OpentelemetrySpanMock) SetNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetName.afterSetNameCounter)
}

// SetNameBeforeCounter returns a count of OpentelemetrySpanMock.SetName invocations
func (mmSetName *OpentelemetrySpanMock) SetNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetName.beforeSetNameCounter)
}

// Calls returns a list of arguments used in each call to OpentelemetrySpanMock.SetName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetName *mOpentelemetrySpanMockSetName) Calls() []*OpentelemetrySpanMockSetNameParams {
	mmSetName.mutex.RLock()

	argCopy := make([]*OpentelemetrySpanMockSetNameParams, len(mmSetName.callArgs))
	copy(argCopy, mmSetName.callArgs)

	mmSetName.mutex.RUnlock()

	return argCopy
}

// MinimockSetNameDone returns true if the count of the SetName invocations corresponds
// the number of defined expectations
func (m *OpentelemetrySpanMock) MinimockSetNameDone() bool {
	for _, e := range m.SetNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetName != nil && mm_atomic.LoadUint64(&m.afterSetNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetNameInspect logs each unmet expectation
func (m *OpentelemetrySpanMock) MinimockSetNameInspect() {
	for _, e := range m.SetNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.SetName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetNameCounter) < 1 {
		if m.SetNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OpentelemetrySpanMock.SetName")
		} else {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.SetName with params: %#v", *m.SetNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetName != nil && mm_atomic.LoadUint64(&m.afterSetNameCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.SetName")
	}
}

type mOpentelemetrySpanMockSetStatus struct {
	mock               *OpentelemetrySpanMock
	defaultExpectation *OpentelemetrySpanMockSetStatusExpectation
	expectations       []*OpentelemetrySpanMockSetStatusExpectation

	callArgs []*OpentelemetrySpanMockSetStatusParams
	mutex    sync.RWMutex
}

// OpentelemetrySpanMockSetStatusExpectation specifies expectation struct of the Span.SetStatus
type OpentelemetrySpanMockSetStatusExpectation struct {
	mock   *OpentelemetrySpanMock
	params *OpentelemetrySpanMockSetStatusParams

	Counter uint64
}

// OpentelemetrySpanMockSetStatusParams contains parameters of the Span.SetStatus
type OpentelemetrySpanMockSetStatusParams struct {
	code        codes.Code
	description string
}

// Expect sets up expected params for Span.SetStatus
func (mmSetStatus *mOpentelemetrySpanMockSetStatus) Expect(code codes.Code, description string) *mOpentelemetrySpanMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OpentelemetrySpanMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OpentelemetrySpanMockSetStatusExpectation{}
	}

	mmSetStatus.defaultExpectation.params = &OpentelemetrySpanMockSetStatusParams{code, description}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the Span.SetStatus
func (mmSetStatus *mOpentelemetrySpanMockSetStatus) Inspect(f func(code codes.Code, description string)) *mOpentelemetrySpanMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OpentelemetrySpanMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by Span.SetStatus
func (mmSetStatus *mOpentelemetrySpanMockSetStatus) Return() *OpentelemetrySpanMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OpentelemetrySpanMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OpentelemetrySpanMockSetStatusExpectation{mock: mmSetStatus.mock}
	}

	return mmSetStatus.mock
}

// Set uses given function f to mock the Span.SetStatus method
func (mmSetStatus *mOpentelemetrySpanMockSetStatus) Set(f func(code codes.Code, description string)) *OpentelemetrySpanMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the Span.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the Span.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// SetStatus implements trace.Span
func (mmSetStatus *OpentelemetrySpanMock) SetStatus(code codes.Code, description string) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(code, description)
	}

	mm_params := &OpentelemetrySpanMockSetStatusParams{code, description}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_got := OpentelemetrySpanMockSetStatusParams{code, description}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OpentelemetrySpanMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetStatus.funcSetStatus != nil {
		mmSetStatus.funcSetStatus(code, description)
		return
	}
	mmSetStatus.t.Fatalf("Unexpected call to OpentelemetrySpanMock.SetStatus. %v %v", code, description)

}

// SetStatusAfterCounter returns a count of finished OpentelemetrySpanMock.SetStatus invocations
func (mmSetStatus *OpentelemetrySpanMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OpentelemetrySpanMock.SetStatus invocations
func (mmSetStatus *OpentelemetrySpanMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OpentelemetrySpanMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOpentelemetrySpanMockSetStatus) Calls() []*OpentelemetrySpanMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OpentelemetrySpanMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OpentelemetrySpanMock) MinimockSetStatusDone() bool {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OpentelemetrySpanMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.SetStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OpentelemetrySpanMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to OpentelemetrySpanMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.SetStatus")
	}
}

type mOpentelemetrySpanMockSpanContext struct {
	mock               *OpentelemetrySpanMock
	defaultExpectation *OpentelemetrySpanMockSpanContextExpectation
	expectations       []*OpentelemetrySpanMockSpanContextExpectation
}

// OpentelemetrySpanMockSpanContextExpectation specifies expectation struct of the Span.SpanContext
type OpentelemetrySpanMockSpanContextExpectation struct {
	mock *OpentelemetrySpanMock

	results *OpentelemetrySpanMockSpanContextResults
	Counter uint64
}

// OpentelemetrySpanMockSpanContextResults contains results of the Span.SpanContext
type OpentelemetrySpanMockSpanContextResults struct {
	s1 mm_trace.SpanContext
}

// Expect sets up expected params for Span.SpanContext
func (mmSpanContext *mOpentelemetrySpanMockSpanContext) Expect() *mOpentelemetrySpanMockSpanContext {
	if mmSpanContext.mock.funcSpanContext != nil {
		mmSpanContext.mock.t.Fatalf("OpentelemetrySpanMock.SpanContext mock is already set by Set")
	}

	if mmSpanContext.defaultExpectation == nil {
		mmSpanContext.defaultExpectation = &OpentelemetrySpanMockSpanContextExpectation{}
	}

	return mmSpanContext
}

// Inspect accepts an inspector function that has same arguments as the Span.SpanContext
func (mmSpanContext *mOpentelemetrySpanMockSpanContext) Inspect(f func()) *mOpentelemetrySpanMockSpanContext {
	if mmSpanContext.mock.inspectFuncSpanContext != nil {
		mmSpanContext.mock.t.Fatalf("Inspect function is already set for OpentelemetrySpanMock.SpanContext")
	}

	mmSpanContext.mock.inspectFuncSpanContext = f

	return mmSpanContext
}

// Return sets up results that will be returned by Span.SpanContext
func (mmSpanContext *mOpentelemetrySpanMockSpanContext) Return(s1 mm_trace.SpanContext) *OpentelemetrySpanMock {
	if mmSpanContext.mock.funcSpanContext != nil {
		mmSpanContext.mock.t.Fatalf("OpentelemetrySpanMock.SpanContext mock is already set by Set")
	}

	if mmSpanContext.defaultExpectation == nil {
		mmSpanContext.defaultExpectation = &OpentelemetrySpanMockSpanContextExpectation{mock: mmSpanContext.mock}
	}
	mmSpanContext.defaultExpectation.results = &OpentelemetrySpanMockSpanContextResults{s1}
	return mmSpanContext.mock
}

// Set uses given function f to mock the Span.SpanContext method
func (mmSpanContext *mOpentelemetrySpanMockSpanContext) Set(f func() (s1 mm_trace.SpanContext)) *OpentelemetrySpanMock {
	if mmSpanContext.defaultExpectation != nil {
		mmSpanContext.mock.t.Fatalf("Default expectation is already set for the Span.SpanContext method")
	}

	if len(mmSpanContext.expectations) > 0 {
		mmSpanContext.mock.t.Fatalf("Some expectations are already set for the Span.SpanContext method")
	}

	mmSpanContext.mock.funcSpanContext = f
	return mmSpanContext.mock
}

// SpanContext implements trace.Span
func (mmSpanContext *OpentelemetrySpanMock) SpanContext() (s1 mm_trace.SpanContext) {
	mm_atomic.AddUint64(&mmSpanContext.beforeSpanContextCounter, 1)
	defer mm_atomic.AddUint64(&mmSpanContext.afterSpanContextCounter, 1)

	if mmSpanContext.inspectFuncSpanContext != nil {
		mmSpanContext.inspectFuncSpanContext()
	}

	if mmSpanContext.SpanContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSpanContext.SpanContextMock.defaultExpectation.Counter, 1)

		mm_results := mmSpanContext.SpanContextMock.defaultExpectation.results
		if mm_results == nil {
			mmSpanContext.t.Fatal("No results are set for the OpentelemetrySpanMock.SpanContext")
		}
		return (*mm_results).s1
	}
	if mmSpanContext.funcSpanContext != nil {
		return mmSpanContext.funcSpanContext()
	}
	mmSpanContext.t.Fatalf("Unexpected call to OpentelemetrySpanMock.SpanContext.")
	return
}

// SpanContextAfterCounter returns a count of finished OpentelemetrySpanMock.SpanContext invocations
func (mmSpanContext *OpentelemetrySpanMock) SpanContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSpanContext.afterSpanContextCounter)
}

// SpanContextBeforeCounter returns a count of OpentelemetrySpanMock.SpanContext invocations
func (mmSpanContext *OpentelemetrySpanMock) SpanContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSpanContext.beforeSpanContextCounter)
}

// MinimockSpanContextDone returns true if the count of the SpanContext invocations corresponds
// the number of defined expectations
func (m *OpentelemetrySpanMock) MinimockSpanContextDone() bool {
	for _, e := range m.SpanContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SpanContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSpanContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSpanContext != nil && mm_atomic.LoadUint64(&m.afterSpanContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockSpanContextInspect logs each unmet expectation
func (m *OpentelemetrySpanMock) MinimockSpanContextInspect() {
	for _, e := range m.SpanContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to OpentelemetrySpanMock.SpanContext")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SpanContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSpanContextCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.SpanContext")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSpanContext != nil && mm_atomic.LoadUint64(&m.afterSpanContextCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.SpanContext")
	}
}

type mOpentelemetrySpanMockTracerProvider struct {
	mock               *OpentelemetrySpanMock
	defaultExpectation *OpentelemetrySpanMockTracerProviderExpectation
	expectations       []*OpentelemetrySpanMockTracerProviderExpectation
}

// OpentelemetrySpanMockTracerProviderExpectation specifies expectation struct of the Span.TracerProvider
type OpentelemetrySpanMockTracerProviderExpectation struct {
	mock *OpentelemetrySpanMock

	results *OpentelemetrySpanMockTracerProviderResults
	Counter uint64
}

// OpentelemetrySpanMockTracerProviderResults contains results of the Span.TracerProvider
type OpentelemetrySpanMockTracerProviderResults struct {
	t1 mm_trace.TracerProvider
}

// Expect sets up expected params for Span.TracerProvider
func (mmTracerProvider *mOpentelemetrySpanMockTracerProvider) Expect() *mOpentelemetrySpanMockTracerProvider {
	if mmTracerProvider.mock.funcTracerProvider != nil {
		mmTracerProvider.mock.t.Fatalf("OpentelemetrySpanMock.TracerProvider mock is already set by Set")
	}

	if mmTracerProvider.defaultExpectation == nil {
		mmTracerProvider.defaultExpectation = &OpentelemetrySpanMockTracerProviderExpectation{}
	}

	return mmTracerProvider
}

// Inspect accepts an inspector function that has same arguments as the Span.TracerProvider
func (mmTracerProvider *mOpentelemetrySpanMockTracerProvider) Inspect(f func()) *mOpentelemetrySpanMockTracerProvider {
	if mmTracerProvider.mock.inspectFuncTracerProvider != nil {
		mmTracerProvider.mock.t.Fatalf("Inspect function is already set for OpentelemetrySpanMock.TracerProvider")
	}

	mmTracerProvider.mock.inspectFuncTracerProvider = f

	return mmTracerProvider
}

// Return sets up results that will be returned by Span.TracerProvider
func (mmTracerProvider *mOpentelemetrySpanMockTracerProvider) Return(t1 mm_trace.TracerProvider) *OpentelemetrySpanMock {
	if mmTracerProvider.mock.funcTracerProvider != nil {
		mmTracerProvider.mock.t.Fatalf("OpentelemetrySpanMock.TracerProvider mock is already set by Set")
	}

	if mmTracerProvider.defaultExpectation == nil {
		mmTracerProvider.defaultExpectation = &OpentelemetrySpanMockTracerProviderExpectation{mock: mmTracerProvider.mock}
	}
	mmTracerProvider.defaultExpectation.results = &OpentelemetrySpanMockTracerProviderResults{t1}
	return mmTracerProvider.mock
}

// Set uses given function f to mock the Span.TracerProvider method
func (mmTracerProvider *mOpentelemetrySpanMockTracerProvider) Set(f func() (t1 mm_trace.TracerProvider)) *OpentelemetrySpanMock {
	if mmTracerProvider.defaultExpectation != nil {
		mmTracerProvider.mock.t.Fatalf("Default expectation is already set for the Span.TracerProvider method")
	}

	if len(mmTracerProvider.expectations) > 0 {
		mmTracerProvider.mock.t.Fatalf("Some expectations are already set for the Span.TracerProvider method")
	}

	mmTracerProvider.mock.funcTracerProvider = f
	return mmTracerProvider.mock
}

// TracerProvider implements trace.Span
func (mmTracerProvider *OpentelemetrySpanMock) TracerProvider() (t1 mm_trace.TracerProvider) {
	mm_atomic.AddUint64(&mmTracerProvider.beforeTracerProviderCounter, 1)
	defer mm_atomic.AddUint64(&mmTracerProvider.afterTracerProviderCounter, 1)

	if mmTracerProvider.inspectFuncTracerProvider != nil {
		mmTracerProvider.inspectFuncTracerProvider()
	}

	if mmTracerProvider.TracerProviderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTracerProvider.TracerProviderMock.defaultExpectation.Counter, 1)

		mm_results := mmTracerProvider.TracerProviderMock.defaultExpectation.results
		if mm_results == nil {
			mmTracerProvider.t.Fatal("No results are set for the OpentelemetrySpanMock.TracerProvider")
		}
		return (*mm_results).t1
	}
	if mmTracerProvider.funcTracerProvider != nil {
		return mmTracerProvider.funcTracerProvider()
	}
	mmTracerProvider.t.Fatalf("Unexpected call to OpentelemetrySpanMock.TracerProvider.")
	return
}

// TracerProviderAfterCounter returns a count of finished OpentelemetrySpanMock.TracerProvider invocations
func (mmTracerProvider *OpentelemetrySpanMock) TracerProviderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTracerProvider.afterTracerProviderCounter)
}

// TracerProviderBeforeCounter returns a count of OpentelemetrySpanMock.TracerProvider invocations
func (mmTracerProvider *OpentelemetrySpanMock) TracerProviderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTracerProvider.beforeTracerProviderCounter)
}

// MinimockTracerProviderDone returns true if the count of the TracerProvider invocations corresponds
// the number of defined expectations
func (m *OpentelemetrySpanMock) MinimockTracerProviderDone() bool {
	for _, e := range m.TracerProviderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TracerProviderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTracerProviderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTracerProvider != nil && mm_atomic.LoadUint64(&m.afterTracerProviderCounter) < 1 {
		return false
	}
	return true
}

// MinimockTracerProviderInspect logs each unmet expectation
func (m *OpentelemetrySpanMock) MinimockTracerProviderInspect() {
	for _, e := range m.TracerProviderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to OpentelemetrySpanMock.TracerProvider")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TracerProviderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTracerProviderCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.TracerProvider")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTracerProvider != nil && mm_atomic.LoadUint64(&m.afterTracerProviderCounter) < 1 {
		m.t.Error("Expected call to OpentelemetrySpanMock.TracerProvider")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OpentelemetrySpanMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddEventInspect()

		m.MinimockEndInspect()

		m.MinimockIsRecordingInspect()

		m.MinimockRecordErrorInspect()

		m.MinimockSetAttributesInspect()

		m.MinimockSetNameInspect()

		m.MinimockSetStatusInspect()

		m.MinimockSpanContextInspect()

		m.MinimockTracerProviderInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OpentelemetrySpanMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OpentelemetrySpanMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddEventDone() &&
		m.MinimockEndDone() &&
		m.MinimockIsRecordingDone() &&
		m.MinimockRecordErrorDone() &&
		m.MinimockSetAttributesDone() &&
		m.MinimockSetNameDone() &&
		m.MinimockSetStatusDone() &&
		m.MinimockSpanContextDone() &&
		m.MinimockTracerProviderDone()
}
