package templatestests

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/hexdigest/gowrap/templates_tests.ElasticAPM -o ./elastic_apm_mock_test.go -n ElasticAPMMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"go.elastic.co/apm/v2"
)

// ElasticAPMMock implements ElasticAPM
type ElasticAPMMock struct {
	t minimock.Tester

	funcCaptureError          func(ctx context.Context, err error)
	inspectFuncCaptureError   func(ctx context.Context, err error)
	afterCaptureErrorCounter  uint64
	beforeCaptureErrorCounter uint64
	CaptureErrorMock          mElasticAPMMockCaptureError

	funcEndSpan          func(span *apm.Span)
	inspectFuncEndSpan   func(span *apm.Span)
	afterEndSpanCounter  uint64
	beforeEndSpanCounter uint64
	EndSpanMock          mElasticAPMMockEndSpan

	funcSetLabel          func(span *apm.Span, key string, value interface{})
	inspectFuncSetLabel   func(span *apm.Span, key string, value interface{})
	afterSetLabelCounter  uint64
	beforeSetLabelCounter uint64
	SetLabelMock          mElasticAPMMockSetLabel

	funcStartSpan          func(ctx context.Context, name string, spanType string) (sp1 *apm.Span, c2 context.Context)
	inspectFuncStartSpan   func(ctx context.Context, name string, spanType string)
	afterStartSpanCounter  uint64
	beforeStartSpanCounter uint64
	StartSpanMock          mElasticAPMMockStartSpan
}

// NewElasticAPMMock returns a mock for ElasticAPM
func NewElasticAPMMock(t minimock.Tester) *ElasticAPMMock {
	m := &ElasticAPMMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CaptureErrorMock = mElasticAPMMockCaptureError{mock: m}
	m.CaptureErrorMock.callArgs = []*ElasticAPMMockCaptureErrorParams{}

	m.EndSpanMock = mElasticAPMMockEndSpan{mock: m}
	m.EndSpanMock.callArgs = []*ElasticAPMMockEndSpanParams{}

	m.SetLabelMock = mElasticAPMMockSetLabel{mock: m}
	m.SetLabelMock.callArgs = []*ElasticAPMMockSetLabelParams{}

	m.StartSpanMock = mElasticAPMMockStartSpan{mock: m}
	m.StartSpanMock.callArgs = []*ElasticAPMMockStartSpanParams{}

	return m
}

type mElasticAPMMockCaptureError struct {
	mock               *ElasticAPMMock
	defaultExpectation *ElasticAPMMockCaptureErrorExpectation
	expectations       []*ElasticAPMMockCaptureErrorExpectation

	callArgs []*ElasticAPMMockCaptureErrorParams
	mutex    sync.RWMutex
}

// ElasticAPMMockCaptureErrorExpectation specifies expectation struct of the ElasticAPM.CaptureError
type ElasticAPMMockCaptureErrorExpectation struct {
	mock   *ElasticAPMMock
	params *ElasticAPMMockCaptureErrorParams

	Counter uint64
}

// ElasticAPMMockCaptureErrorParams contains parameters of the ElasticAPM.CaptureError
type ElasticAPMMockCaptureErrorParams struct {
	ctx context.Context
	err error
}

// Expect sets up expected params for ElasticAPM.CaptureError
func (mmCaptureError *mElasticAPMMockCaptureError) Expect(ctx context.Context, err error) *mElasticAPMMockCaptureError {
	if mmCaptureError.mock.funcCaptureError != nil {
		mmCaptureError.mock.t.Fatalf("ElasticAPMMock.CaptureError mock is already set by Set")
	}

	if mmCaptureError.defaultExpectation == nil {
		mmCaptureError.defaultExpectation = &ElasticAPMMockCaptureErrorExpectation{}
	}

	mmCaptureError.defaultExpectation.params = &ElasticAPMMockCaptureErrorParams{ctx, err}
	for _, e := range mmCaptureError.expectations {
		if minimock.Equal(e.params, mmCaptureError.defaultExpectation.params) {
			mmCaptureError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCaptureError.defaultExpectation.params)
		}
	}

	return mmCaptureError
}

// Inspect accepts an inspector function that has same arguments as the ElasticAPM.CaptureError
func (mmCaptureError *mElasticAPMMockCaptureError) Inspect(f func(ctx context.Context, err error)) *mElasticAPMMockCaptureError {
	if mmCaptureError.mock.inspectFuncCaptureError != nil {
		mmCaptureError.mock.t.Fatalf("Inspect function is already set for ElasticAPMMock.CaptureError")
	}

	mmCaptureError.mock.inspectFuncCaptureError = f

	return mmCaptureError
}

// Return sets up results that will be returned by ElasticAPM.CaptureError
func (mmCaptureError *mElasticAPMMockCaptureError) Return() *ElasticAPMMock {
	if mmCaptureError.mock.funcCaptureError != nil {
		mmCaptureError.mock.t.Fatalf("ElasticAPMMock.CaptureError mock is already set by Set")
	}

	if mmCaptureError.defaultExpectation == nil {
		mmCaptureError.defaultExpectation = &ElasticAPMMockCaptureErrorExpectation{mock: mmCaptureError.mock}
	}

	return mmCaptureError.mock
}

// Set uses given function f to mock the ElasticAPM.CaptureError method
func (mmCaptureError *mElasticAPMMockCaptureError) Set(f func(ctx context.Context, err error)) *ElasticAPMMock {
	if mmCaptureError.defaultExpectation != nil {
		mmCaptureError.mock.t.Fatalf("Default expectation is already set for the ElasticAPM.CaptureError method")
	}

	if len(mmCaptureError.expectations) > 0 {
		mmCaptureError.mock.t.Fatalf("Some expectations are already set for the ElasticAPM.CaptureError method")
	}

	mmCaptureError.mock.funcCaptureError = f
	return mmCaptureError.mock
}

// CaptureError implements ElasticAPM
func (mmCaptureError *ElasticAPMMock) CaptureError(ctx context.Context, err error) {
	mm_atomic.AddUint64(&mmCaptureError.beforeCaptureErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmCaptureError.afterCaptureErrorCounter, 1)

	if mmCaptureError.inspectFuncCaptureError != nil {
		mmCaptureError.inspectFuncCaptureError(ctx, err)
	}

	mm_params := &ElasticAPMMockCaptureErrorParams{ctx, err}

	// Record call args
	mmCaptureError.CaptureErrorMock.mutex.Lock()
	mmCaptureError.CaptureErrorMock.callArgs = append(mmCaptureError.CaptureErrorMock.callArgs, mm_params)
	mmCaptureError.CaptureErrorMock.mutex.Unlock()

	for _, e := range mmCaptureError.CaptureErrorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCaptureError.CaptureErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCaptureError.CaptureErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmCaptureError.CaptureErrorMock.defaultExpectation.params
		mm_got := ElasticAPMMockCaptureErrorParams{ctx, err}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCaptureError.t.Errorf("ElasticAPMMock.CaptureError got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCaptureError.funcCaptureError != nil {
		mmCaptureError.funcCaptureError(ctx, err)
		return
	}
	mmCaptureError.t.Fatalf("Unexpected call to ElasticAPMMock.CaptureError. %v %v", ctx, err)

}

// CaptureErrorAfterCounter returns a count of finished ElasticAPMMock.CaptureError invocations
func (mmCaptureError *ElasticAPMMock) CaptureErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCaptureError.afterCaptureErrorCounter)
}

// CaptureErrorBeforeCounter returns a count of ElasticAPMMock.CaptureError invocations
func (mmCaptureError *ElasticAPMMock) CaptureErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCaptureError.beforeCaptureErrorCounter)
}

// Calls returns a list of arguments used in each call to ElasticAPMMock.CaptureError.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCaptureError *mElasticAPMMockCaptureError) Calls() []*ElasticAPMMockCaptureErrorParams {
	mmCaptureError.mutex.RLock()

	argCopy := make([]*ElasticAPMMockCaptureErrorParams, len(mmCaptureError.callArgs))
	copy(argCopy, mmCaptureError.callArgs)

	mmCaptureError.mutex.RUnlock()

	return argCopy
}

// MinimockCaptureErrorDone returns true if the count of the CaptureError invocations corresponds
// the number of defined expectations
func (m *ElasticAPMMock) MinimockCaptureErrorDone() bool {
	for _, e := range m.CaptureErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CaptureErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCaptureErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCaptureError != nil && mm_atomic.LoadUint64(&m.afterCaptureErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockCaptureErrorInspect logs each unmet expectation
func (m *ElasticAPMMock) MinimockCaptureErrorInspect() {
	for _, e := range m.CaptureErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ElasticAPMMock.CaptureError with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CaptureErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCaptureErrorCounter) < 1 {
		if m.CaptureErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ElasticAPMMock.CaptureError")
		} else {
			m.t.Errorf("Expected call to ElasticAPMMock.CaptureError with params: %#v", *m.CaptureErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCaptureError != nil && mm_atomic.LoadUint64(&m.afterCaptureErrorCounter) < 1 {
		m.t.Error("Expected call to ElasticAPMMock.CaptureError")
	}
}

type mElasticAPMMockEndSpan struct {
	mock               *ElasticAPMMock
	defaultExpectation *ElasticAPMMockEndSpanExpectation
	expectations       []*ElasticAPMMockEndSpanExpectation

	callArgs []*ElasticAPMMockEndSpanParams
	mutex    sync.RWMutex
}

// ElasticAPMMockEndSpanExpectation specifies expectation struct of the ElasticAPM.EndSpan
type ElasticAPMMockEndSpanExpectation struct {
	mock   *ElasticAPMMock
	params *ElasticAPMMockEndSpanParams

	Counter uint64
}

// ElasticAPMMockEndSpanParams contains parameters of the ElasticAPM.EndSpan
type ElasticAPMMockEndSpanParams struct {
	span *apm.Span
}

// Expect sets up expected params for ElasticAPM.EndSpan
func (mmEndSpan *mElasticAPMMockEndSpan) Expect(span *apm.Span) *mElasticAPMMockEndSpan {
	if mmEndSpan.mock.funcEndSpan != nil {
		mmEndSpan.mock.t.Fatalf("ElasticAPMMock.EndSpan mock is already set by Set")
	}

	if mmEndSpan.defaultExpectation == nil {
		mmEndSpan.defaultExpectation = &ElasticAPMMockEndSpanExpectation{}
	}

	mmEndSpan.defaultExpectation.params = &ElasticAPMMockEndSpanParams{span}
	for _, e := range mmEndSpan.expectations {
		if minimock.Equal(e.params, mmEndSpan.defaultExpectation.params) {
			mmEndSpan.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEndSpan.defaultExpectation.params)
		}
	}

	return mmEndSpan
}

// Inspect accepts an inspector function that has same arguments as the ElasticAPM.EndSpan
func (mmEndSpan *mElasticAPMMockEndSpan) Inspect(f func(span *apm.Span)) *mElasticAPMMockEndSpan {
	if mmEndSpan.mock.inspectFuncEndSpan != nil {
		mmEndSpan.mock.t.Fatalf("Inspect function is already set for ElasticAPMMock.EndSpan")
	}

	mmEndSpan.mock.inspectFuncEndSpan = f

	return mmEndSpan
}

// Return sets up results that will be returned by ElasticAPM.EndSpan
func (mmEndSpan *mElasticAPMMockEndSpan) Return() *ElasticAPMMock {
	if mmEndSpan.mock.funcEndSpan != nil {
		mmEndSpan.mock.t.Fatalf("ElasticAPMMock.EndSpan mock is already set by Set")
	}

	if mmEndSpan.defaultExpectation == nil {
		mmEndSpan.defaultExpectation = &ElasticAPMMockEndSpanExpectation{mock: mmEndSpan.mock}
	}

	return mmEndSpan.mock
}

// Set uses given function f to mock the ElasticAPM.EndSpan method
func (mmEndSpan *mElasticAPMMockEndSpan) Set(f func(span *apm.Span)) *ElasticAPMMock {
	if mmEndSpan.defaultExpectation != nil {
		mmEndSpan.mock.t.Fatalf("Default expectation is already set for the ElasticAPM.EndSpan method")
	}

	if len(mmEndSpan.expectations) > 0 {
		mmEndSpan.mock.t.Fatalf("Some expectations are already set for the ElasticAPM.EndSpan method")
	}

	mmEndSpan.mock.funcEndSpan = f
	return mmEndSpan.mock
}

// EndSpan implements ElasticAPM
func (mmEndSpan *ElasticAPMMock) EndSpan(span *apm.Span) {
	mm_atomic.AddUint64(&mmEndSpan.beforeEndSpanCounter, 1)
	defer mm_atomic.AddUint64(&mmEndSpan.afterEndSpanCounter, 1)

	if mmEndSpan.inspectFuncEndSpan != nil {
		mmEndSpan.inspectFuncEndSpan(span)
	}

	mm_params := &ElasticAPMMockEndSpanParams{span}

	// Record call args
	mmEndSpan.EndSpanMock.mutex.Lock()
	mmEndSpan.EndSpanMock.callArgs = append(mmEndSpan.EndSpanMock.callArgs, mm_params)
	mmEndSpan.EndSpanMock.mutex.Unlock()

	for _, e := range mmEndSpan.EndSpanMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmEndSpan.EndSpanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEndSpan.EndSpanMock.defaultExpectation.Counter, 1)
		mm_want := mmEndSpan.EndSpanMock.defaultExpectation.params
		mm_got := ElasticAPMMockEndSpanParams{span}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEndSpan.t.Errorf("ElasticAPMMock.EndSpan got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmEndSpan.funcEndSpan != nil {
		mmEndSpan.funcEndSpan(span)
		return
	}
	mmEndSpan.t.Fatalf("Unexpected call to ElasticAPMMock.EndSpan. %v", span)

}

// EndSpanAfterCounter returns a count of finished ElasticAPMMock.EndSpan invocations
func (mmEndSpan *ElasticAPMMock) EndSpanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEndSpan.afterEndSpanCounter)
}

// EndSpanBeforeCounter returns a count of ElasticAPMMock.EndSpan invocations
func (mmEndSpan *ElasticAPMMock) EndSpanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEndSpan.beforeEndSpanCounter)
}

// Calls returns a list of arguments used in each call to ElasticAPMMock.EndSpan.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEndSpan *mElasticAPMMockEndSpan) Calls() []*ElasticAPMMockEndSpanParams {
	mmEndSpan.mutex.RLock()

	argCopy := make([]*ElasticAPMMockEndSpanParams, len(mmEndSpan.callArgs))
	copy(argCopy, mmEndSpan.callArgs)

	mmEndSpan.mutex.RUnlock()

	return argCopy
}

// MinimockEndSpanDone returns true if the count of the EndSpan invocations corresponds
// the number of defined expectations
func (m *ElasticAPMMock) MinimockEndSpanDone() bool {
	for _, e := range m.EndSpanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EndSpanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEndSpanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEndSpan != nil && mm_atomic.LoadUint64(&m.afterEndSpanCounter) < 1 {
		return false
	}
	return true
}

// MinimockEndSpanInspect logs each unmet expectation
func (m *ElasticAPMMock) MinimockEndSpanInspect() {
	for _, e := range m.EndSpanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ElasticAPMMock.EndSpan with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EndSpanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEndSpanCounter) < 1 {
		if m.EndSpanMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ElasticAPMMock.EndSpan")
		} else {
			m.t.Errorf("Expected call to ElasticAPMMock.EndSpan with params: %#v", *m.EndSpanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEndSpan != nil && mm_atomic.LoadUint64(&m.afterEndSpanCounter) < 1 {
		m.t.Error("Expected call to ElasticAPMMock.EndSpan")
	}
}

type mElasticAPMMockSetLabel struct {
	mock               *ElasticAPMMock
	defaultExpectation *ElasticAPMMockSetLabelExpectation
	expectations       []*ElasticAPMMockSetLabelExpectation

	callArgs []*ElasticAPMMockSetLabelParams
	mutex    sync.RWMutex
}

// ElasticAPMMockSetLabelExpectation specifies expectation struct of the ElasticAPM.SetLabel
type ElasticAPMMockSetLabelExpectation struct {
	mock   *ElasticAPMMock
	params *ElasticAPMMockSetLabelParams

	Counter uint64
}

// ElasticAPMMockSetLabelParams contains parameters of the ElasticAPM.SetLabel
type ElasticAPMMockSetLabelParams struct {
	span  *apm.Span
	key   string
	value interface{}
}

// Expect sets up expected params for ElasticAPM.SetLabel
func (mmSetLabel *mElasticAPMMockSetLabel) Expect(span *apm.Span, key string, value interface{}) *mElasticAPMMockSetLabel {
	if mmSetLabel.mock.funcSetLabel != nil {
		mmSetLabel.mock.t.Fatalf("ElasticAPMMock.SetLabel mock is already set by Set")
	}

	if mmSetLabel.defaultExpectation == nil {
		mmSetLabel.defaultExpectation = &ElasticAPMMockSetLabelExpectation{}
	}

	mmSetLabel.defaultExpectation.params = &ElasticAPMMockSetLabelParams{span, key, value}
	for _, e := range mmSetLabel.expectations {
		if minimock.Equal(e.params, mmSetLabel.defaultExpectation.params) {
			mmSetLabel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetLabel.defaultExpectation.params)
		}
	}

	return mmSetLabel
}

// Inspect accepts an inspector function that has same arguments as the ElasticAPM.SetLabel
func (mmSetLabel *mElasticAPMMockSetLabel) Inspect(f func(span *apm.Span, key string, value interface{})) *mElasticAPMMockSetLabel {
	if mmSetLabel.mock.inspectFuncSetLabel != nil {
		mmSetLabel.mock.t.Fatalf("Inspect function is already set for ElasticAPMMock.SetLabel")
	}

	mmSetLabel.mock.inspectFuncSetLabel = f

	return mmSetLabel
}

// Return sets up results that will be returned by ElasticAPM.SetLabel
func (mmSetLabel *mElasticAPMMockSetLabel) Return() *ElasticAPMMock {
	if mmSetLabel.mock.funcSetLabel != nil {
		mmSetLabel.mock.t.Fatalf("ElasticAPMMock.SetLabel mock is already set by Set")
	}

	if mmSetLabel.defaultExpectation == nil {
		mmSetLabel.defaultExpectation = &ElasticAPMMockSetLabelExpectation{mock: mmSetLabel.mock}
	}

	return mmSetLabel.mock
}

// Set uses given function f to mock the ElasticAPM.SetLabel method
func (mmSetLabel *mElasticAPMMockSetLabel) Set(f func(span *apm.Span, key string, value interface{})) *ElasticAPMMock {
	if mmSetLabel.defaultExpectation != nil {
		mmSetLabel.mock.t.Fatalf("Default expectation is already set for the ElasticAPM.SetLabel method")
	}

	if len(mmSetLabel.expectations) > 0 {
		mmSetLabel.mock.t.Fatalf("Some expectations are already set for the ElasticAPM.SetLabel method")
	}

	mmSetLabel.mock.funcSetLabel = f
	return mmSetLabel.mock
}

// SetLabel implements ElasticAPM
func (mmSetLabel *ElasticAPMMock) SetLabel(span *apm.Span, key string, value interface{}) {
	mm_atomic.AddUint64(&mmSetLabel.beforeSetLabelCounter, 1)
	defer mm_atomic.AddUint64(&mmSetLabel.afterSetLabelCounter, 1)

	if mmSetLabel.inspectFuncSetLabel != nil {
		mmSetLabel.inspectFuncSetLabel(span, key, value)
	}

	mm_params := &ElasticAPMMockSetLabelParams{span, key, value}

	// Record call args
	mmSetLabel.SetLabelMock.mutex.Lock()
	mmSetLabel.SetLabelMock.callArgs = append(mmSetLabel.SetLabelMock.callArgs, mm_params)
	mmSetLabel.SetLabelMock.mutex.Unlock()

	for _, e := range mmSetLabel.SetLabelMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetLabel.SetLabelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetLabel.SetLabelMock.defaultExpectation.Counter, 1)
		mm_want := mmSetLabel.SetLabelMock.defaultExpectation.params
		mm_got := ElasticAPMMockSetLabelParams{span, key, value}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetLabel.t.Errorf("ElasticAPMMock.SetLabel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetLabel.funcSetLabel != nil {
		mmSetLabel.funcSetLabel(span, key, value)
		return
	}
	mmSetLabel.t.Fatalf("Unexpected call to ElasticAPMMock.SetLabel. %v %v %v", span, key, value)

}

// SetLabelAfterCounter returns a count of finished ElasticAPMMock.SetLabel invocations
func (mmSetLabel *ElasticAPMMock) SetLabelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLabel.afterSetLabelCounter)
}

// SetLabelBeforeCounter returns a count of ElasticAPMMock.SetLabel invocations
func (mmSetLabel *ElasticAPMMock) SetLabelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetLabel.beforeSetLabelCounter)
}

// Calls returns a list of arguments used in each call to ElasticAPMMock.SetLabel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetLabel *mElasticAPMMockSetLabel) Calls() []*ElasticAPMMockSetLabelParams {
	mmSetLabel.mutex.RLock()

	argCopy := make([]*ElasticAPMMockSetLabelParams, len(mmSetLabel.callArgs))
	copy(argCopy, mmSetLabel.callArgs)

	mmSetLabel.mutex.RUnlock()

	return argCopy
}

// MinimockSetLabelDone returns true if the count of the SetLabel invocations corresponds
// the number of defined expectations
func (m *ElasticAPMMock) MinimockSetLabelDone() bool {
	for _, e := range m.SetLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLabelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLabelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLabel != nil && mm_atomic.LoadUint64(&m.afterSetLabelCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetLabelInspect logs each unmet expectation
func (m *ElasticAPMMock) MinimockSetLabelInspect() {
	for _, e := range m.SetLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ElasticAPMMock.SetLabel with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetLabelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetLabelCounter) < 1 {
		if m.SetLabelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ElasticAPMMock.SetLabel")
		} else {
			m.t.Errorf("Expected call to ElasticAPMMock.SetLabel with params: %#v", *m.SetLabelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetLabel != nil && mm_atomic.LoadUint64(&m.afterSetLabelCounter) < 1 {
		m.t.Error("Expected call to ElasticAPMMock.SetLabel")
	}
}

type mElasticAPMMockStartSpan struct {
	mock               *ElasticAPMMock
	defaultExpectation *ElasticAPMMockStartSpanExpectation
	expectations       []*ElasticAPMMockStartSpanExpectation

	callArgs []*ElasticAPMMockStartSpanParams
	mutex    sync.RWMutex
}

// ElasticAPMMockStartSpanExpectation specifies expectation struct of the ElasticAPM.StartSpan
type ElasticAPMMockStartSpanExpectation struct {
	mock    *ElasticAPMMock
	params  *ElasticAPMMockStartSpanParams
	results *ElasticAPMMockStartSpanResults
	Counter uint64
}

// ElasticAPMMockStartSpanParams contains parameters of the ElasticAPM.StartSpan
type ElasticAPMMockStartSpanParams struct {
	ctx      context.Context
	name     string
	spanType string
}

// ElasticAPMMockStartSpanResults contains results of the ElasticAPM.StartSpan
type ElasticAPMMockStartSpanResults struct {
	sp1 *apm.Span
	c2  context.Context
}

// Expect sets up expected params for ElasticAPM.StartSpan
func (mmStartSpan *mElasticAPMMockStartSpan) Expect(ctx context.Context, name string, spanType string) *mElasticAPMMockStartSpan {
	if mmStartSpan.mock.funcStartSpan != nil {
		mmStartSpan.mock.t.Fatalf("ElasticAPMMock.StartSpan mock is already set by Set")
	}

	if mmStartSpan.defaultExpectation == nil {
		mmStartSpan.defaultExpectation = &ElasticAPMMockStartSpanExpectation{}
	}

	mmStartSpan.defaultExpectation.params = &ElasticAPMMockStartSpanParams{ctx, name, spanType}
	for _, e := range mmStartSpan.expectations {
		if minimock.Equal(e.params, mmStartSpan.defaultExpectation.params) {
			mmStartSpan.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStartSpan.defaultExpectation.params)
		}
	}

	return mmStartSpan
}

// Inspect accepts an inspector function that has same arguments as the ElasticAPM.StartSpan
func (mmStartSpan *mElasticAPMMockStartSpan) Inspect(f func(ctx context.Context, name string, spanType string)) *mElasticAPMMockStartSpan {
	if mmStartSpan.mock.inspectFuncStartSpan != nil {
		mmStartSpan.mock.t.Fatalf("Inspect function is already set for ElasticAPMMock.StartSpan")
	}

	mmStartSpan.mock.inspectFuncStartSpan = f

	return mmStartSpan
}

// Return sets up results that will be returned by ElasticAPM.StartSpan
func (mmStartSpan *mElasticAPMMockStartSpan) Return(sp1 *apm.Span, c2 context.Context) *ElasticAPMMock {
	if mmStartSpan.mock.funcStartSpan != nil {
		mmStartSpan.mock.t.Fatalf("ElasticAPMMock.StartSpan mock is already set by Set")
	}

	if mmStartSpan.defaultExpectation == nil {
		mmStartSpan.defaultExpectation = &ElasticAPMMockStartSpanExpectation{mock: mmStartSpan.mock}
	}
	mmStartSpan.defaultExpectation.results = &ElasticAPMMockStartSpanResults{sp1, c2}
	return mmStartSpan.mock
}

// Set uses given function f to mock the ElasticAPM.StartSpan method
func (mmStartSpan *mElasticAPMMockStartSpan) Set(f func(ctx context.Context, name string, spanType string) (sp1 *apm.Span, c2 context.Context)) *ElasticAPMMock {
	if mmStartSpan.defaultExpectation != nil {
		mmStartSpan.mock.t.Fatalf("Default expectation is already set for the ElasticAPM.StartSpan method")
	}

	if len(mmStartSpan.expectations) > 0 {
		mmStartSpan.mock.t.Fatalf("Some expectations are already set for the ElasticAPM.StartSpan method")
	}

	mmStartSpan.mock.funcStartSpan = f
	return mmStartSpan.mock
}

// When sets expectation for the ElasticAPM.StartSpan which will trigger the result defined by the following
// Then helper
func (mmStartSpan *mElasticAPMMockStartSpan) When(ctx context.Context, name string, spanType string) *ElasticAPMMockStartSpanExpectation {
	if mmStartSpan.mock.funcStartSpan != nil {
		mmStartSpan.mock.t.Fatalf("ElasticAPMMock.StartSpan mock is already set by Set")
	}

	expectation := &ElasticAPMMockStartSpanExpectation{
		mock:   mmStartSpan.mock,
		params: &ElasticAPMMockStartSpanParams{ctx, name, spanType},
	}
	mmStartSpan.expectations = append(mmStartSpan.expectations, expectation)
	return expectation
}

// Then sets up ElasticAPM.StartSpan return parameters for the expectation previously defined by the When method
func (e *ElasticAPMMockStartSpanExpectation) Then(sp1 *apm.Span, c2 context.Context) *ElasticAPMMock {
	e.results = &ElasticAPMMockStartSpanResults{sp1, c2}
	return e.mock
}

// StartSpan implements ElasticAPM
func (mmStartSpan *ElasticAPMMock) StartSpan(ctx context.Context, name string, spanType string) (sp1 *apm.Span, c2 context.Context) {
	mm_atomic.AddUint64(&mmStartSpan.beforeStartSpanCounter, 1)
	defer mm_atomic.AddUint64(&mmStartSpan.afterStartSpanCounter, 1)

	if mmStartSpan.inspectFuncStartSpan != nil {
		mmStartSpan.inspectFuncStartSpan(ctx, name, spanType)
	}

	mm_params := &ElasticAPMMockStartSpanParams{ctx, name, spanType}

	// Record call args
	mmStartSpan.StartSpanMock.mutex.Lock()
	mmStartSpan.StartSpanMock.callArgs = append(mmStartSpan.StartSpanMock.callArgs, mm_params)
	mmStartSpan.StartSpanMock.mutex.Unlock()

	for _, e := range mmStartSpan.StartSpanMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.c2
		}
	}

	if mmStartSpan.StartSpanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStartSpan.StartSpanMock.defaultExpectation.Counter, 1)
		mm_want := mmStartSpan.StartSpanMock.defaultExpectation.params
		mm_got := ElasticAPMMockStartSpanParams{ctx, name, spanType}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStartSpan.t.Errorf("ElasticAPMMock.StartSpan got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStartSpan.StartSpanMock.defaultExpectation.results
		if mm_results == nil {
			mmStartSpan.t.Fatal("No results are set for the ElasticAPMMock.StartSpan")
		}
		return (*mm_results).sp1, (*mm_results).c2
	}
	if mmStartSpan.funcStartSpan != nil {
		return mmStartSpan.funcStartSpan(ctx, name, spanType)
	}
	mmStartSpan.t.Fatalf("Unexpected call to ElasticAPMMock.StartSpan. %v %v %v", ctx, name, spanType)
	return
}

// StartSpanAfterCounter returns a count of finished ElasticAPMMock.StartSpan invocations
func (mmStartSpan *ElasticAPMMock) StartSpanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartSpan.afterStartSpanCounter)
}

// StartSpanBeforeCounter returns a count of ElasticAPMMock.StartSpan invocations
func (mmStartSpan *ElasticAPMMock) StartSpanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartSpan.beforeStartSpanCounter)
}

// Calls returns a list of arguments used in each call to ElasticAPMMock.StartSpan.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStartSpan *mElasticAPMMockStartSpan) Calls() []*ElasticAPMMockStartSpanParams {
	mmStartSpan.mutex.RLock()

	argCopy := make([]*ElasticAPMMockStartSpanParams, len(mmStartSpan.callArgs))
	copy(argCopy, mmStartSpan.callArgs)

	mmStartSpan.mutex.RUnlock()

	return argCopy
}

// MinimockStartSpanDone returns true if the count of the StartSpan invocations corresponds
// the number of defined expectations
func (m *ElasticAPMMock) MinimockStartSpanDone() bool {
	for _, e := range m.StartSpanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartSpanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartSpanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartSpan != nil && mm_atomic.LoadUint64(&m.afterStartSpanCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartSpanInspect logs each unmet expectation
func (m *ElasticAPMMock) MinimockStartSpanInspect() {
	for _, e := range m.StartSpanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ElasticAPMMock.StartSpan with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartSpanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartSpanCounter) < 1 {
		if m.StartSpanMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ElasticAPMMock.StartSpan")
		} else {
			m.t.Errorf("Expected call to ElasticAPMMock.StartSpan with params: %#v", *m.StartSpanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartSpan != nil && mm_atomic.LoadUint64(&m.afterStartSpanCounter) < 1 {
		m.t.Error("Expected call to ElasticAPMMock.StartSpan")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ElasticAPMMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCaptureErrorInspect()

		m.MinimockEndSpanInspect()

		m.MinimockSetLabelInspect()

		m.MinimockStartSpanInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ElasticAPMMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ElasticAPMMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCaptureErrorDone() &&
		m.MinimockEndSpanDone() &&
		m.MinimockSetLabelDone() &&
		m.MinimockStartSpanDone()
}
